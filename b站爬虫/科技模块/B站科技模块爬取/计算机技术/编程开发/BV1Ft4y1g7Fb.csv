评论,时间,点赞数,标签
杜爹！讲得太好了！我之前看过其他机构教的ioc思想，都是一知半解，今天来听杜爹讲的，真的醍醐灌顶，整个知识的脉络都打通了，知其所以，知其所以然,2022-12-08 07:02:31,2,0
去年看老杜的javase入门，今年看老杜的Spring复习,2022-11-25 05:52:29,2,0
成功唤醒了我脑海里以前学spring的知识，讲的也细致目前每一步都可以跟的上，有基础的几天看完不是问题，希望等我看完之日就是我上班之时。一天12小时的肝，我就不相信搞不定这玩意，加油！,2022-11-19 13:08:10,2,0
听了一半了，老师讲的很好，希望快出spring boot和cloud[呲牙],2022-11-16 09:17:23,7,0
"学完了, 感谢动力节点的课程, 已经拿到饿了么的offer了[doge]",2022-11-16 08:28:11,2,0
感谢老动力节点，唯以一个我全程看下来的， ssm 入门就靠老杜的教程了,2022-11-16 07:58:45,2,0
跟老杜学spring6的第13天 事务的传播特性、spring对AOP的实现：基于xml的方式，基于注解的方式,2022-11-08 00:51:15,2,0
打卡打卡,2022-11-08 00:44:43,2,0
"day14
声明式事务：
PlatformTransactionManager接口，框架提供改接口的实现类，spring6便可以帮助框架管理事务。

默认实现类：
DataSourceTransactionManager，支持mybatis，jdbc
JtaTransactionManager，分布式事务。

注解方式：
1）配置事务管理器，纳入容器管理。
<bean id=""txManager"" class=""xxxx.xxx.DSTM"">，并注入数据源DataSource。
2）开启事务注解
<tx:annotation-driven transaction-manager=""txManager"" >
3）@Transactional注解加在类上或者方法上。

事务的传播特效；Propagation（EUMN）
required：没有就新开一个、有就加入
support：有就加入、没有就没有了
mandatory：有就加入，没有抛异常
required_new：不管有没有直接开启一个新事务，新事务和旧事务不存在嵌套。旧事务被挂起。
not_support：不支持事务、有就挂起
never：存在就抛异常
nestid：有就开启一个嵌套事务，没有和required一样",2022-11-07 15:30:54,4,0
今日学习,2022-11-07 14:21:24,3,0
"【老杜Spring6_学习打卡09】
今天学习到110集，Spring AOP基于注解之所有通知类型",2022-11-07 11:38:32,2,0
"Spring老杜day12
Spring IoC注解式开发
负责声明Bean的注解，常见的包括四个：@Component
@Controller
@Service
@Repository
Spring注解的使用
第一步：加入aop的依赖 
第二步：在配置文件中添加context命名空间
第三步：在配置文件中指定扫描的包 
第四步：在Bean类上使用注解(如果注解的属性名是value，那么是可以省略的。）
负责注入的注解有：@Value ，@Autowired， @Qualifier，@Resource等",2022-11-07 01:43:50,2,0
"【跟着老杜学Spring+第14天】
学习笔记:
老杜牛逼[打call]
Spring单元测试Junit4和5，Spring集成MyBatis，Spring的八大设计模式，工厂，工厂方法，单例，代理，装饰器，观察者，策略，模板方法设计模式，完结撒花，老杜牛逼[打call]",2022-11-07 01:29:40,2,0
"跟着老杜学Spring_Day10
Spring中的事务(上)
1、什么是事务
  在一个业务流程当中，通常需要多条DML（insert delete update）语句共同联合才能完成，这多条DML语句必须同时成功，或者同时失败，这样才能保证数据的安全。
  多条DML要么同时成功，要么同时失败，这叫做事务。
  事务：Transaction（tx）
2、 事务的四个处理过程：
  第一步：开启事务 (start transaction)
  第二步：执行核心业务代码
  第三步：提交事务（如果核心业务处理过程中没有出现异常）(commit transaction)
  第四步：回滚事务（如果核心业务处理过程中出现异常）(rollback transaction)
3、 事务的四个特性：
   A 原子性：事务是最小的工作单元，不可再分。
   C 一致性：事务要求要么同时成功，要么同时失败。事务前和事务后的总量不变。
   I 隔离性：事务和事务之间因为有隔离性，才可以保证互不干扰。
   D 持久性：持久性是事务结束的标志。",2022-11-03 15:49:34,2,0
"跟着老杜学spring的第七天
学习了jdbctemplate，学习封装的jdbc，老杜带着用这个spring中的这个框架，进行了一些增删改查，我感觉，还是用jpa或者mybatis这两个框架比较好",2022-11-01 17:08:30,2,0
"【打卡老杜Spring6-day01】
 1、了解了OCP开闭原则
2、了解依赖倒置原则DIP
3、了解控制反转IoC
4、了解Spring8大模块",2022-11-01 15:59:32,2,0
"spring打卡第七天了，主要是看了spring整合mybatis部分，这里老杜和荣姐的写法一致，王妈妈在spring主配置文件中的写法，略有不同。

到这里就静待老杜的springmvc了，到时候一定光临，最近开始leecode刷题了，后面会学习redis  linux  springboot等课程，会继续跟着动力节点，加油",2022-11-01 15:56:33,2,0
"老杜Spring6打卡Day08
jdk动态的创建：
    1.newProxyInstance 翻译为：新建代理对象
        也就是说，通过调用这个方法可以创建代理对象。
        本质上，这个Proxy.newProxyInstance()方法的执行，做了两件事：
            第一件事：在内存中动态生成了一个代理类的字节码class。
            第二件事：new对象了。通过内存中生成的代理类这个代码，实例化了代理对象。
     2. 关于newProxyInstance()方法的三个重要的参数，每一个什么含义，有什么用？
        第一个参数：ClassLoader loader
          类加载器。这个类加载器有什么用呢？
            在内存中生成的字节码也就是class文件，要执行也得先加载到内存当中。加载类就需要类加载器。所以这里需要指定类加载器。
            并且JDK要求，目标类的类加载器必须和代理类的类加载器使用同一个。
        第二个参数：Class<?>【】 interfaces
            代理类和目标类要实现同一个接口或同一些接口。
            在内存中生成代理类的时候，这个代理类是需要你告诉它实现哪些接口的。
        第三个参数：InvocationHandler h
            InvocationHandler 被翻译为：调用处理器。是一个接口。
            在调用处理器接口中编写的就是：增强代码。
            因为具体要增强什么代码。JDK动态代理结束它是猜不到的。没有那么神。
            既然是接口，就要写接口的实现类。

            可能会有疑问？
              自己还要动手调用处理器接口的实现类，这不会类爆炸吗？不会。
              因为这种调用处理器写一次就好。
         注意：代理对象和目标对象实现的接口一样，所以可以向下转型",2022-11-01 15:21:45,2,0
"标题：跟着老杜学Spring第8天
1.JdbcTemplate

JdbcTemplate是Spring提供的一个JDBC模板类，是对JDBC的封装，简化JDBC代码。

当然，你也可以不用，可以让Spring集成其它的ORM框架，例如：MyBatis、Hibernate等。

接下来我们简单来学习一下，使用JdbcTemplate完成增删改查。

2.update方法有两个参数：

- 第一个参数：要执行的SQL语句。（SQL语句中可能会有占位符 ? ）
- 第二个参数：可变长参数，参数的个数可以是0个，也可以是多个。一般是SQL语句中有几个问号，则对应几个参数。

3.queryForObject方法三个参数：

- 第一个参数：sql语句
- 第二个参数：Bean属性值和数据库记录行的映射对象。在构造方法中指定映射的对象类型。
- 第三个参数：可变长参数，给sql语句的占位符问号传值。",2022-11-01 15:08:54,4,0
"老杜Spring6打卡Day07
Bean的生命周期五步：
    第一步：实例化Bean
    第二步：Bean属性赋值
    第三步：初始化Bean
    第四步：使用Bean
    第五步：销毁Bean；
Bean的生命周期七步：比五步添加的那两步在哪里？在初始化Bean的前和后。
    第一步：实例化Bean
    第二步：给Bean属性赋值
    第三步：执行""Bean后置处理器""的before方法。
    第四步：初始化Bean
    第五步：执行""Bean后置处理器""的after方法。
    第六步：用Bean
    第七步：销毁Bean；
Bean的生命周期十步：比七步添加的那三步在哪里？
    点位1：在""Bean后处理器""before方法之前
        干了什么事？
          检查Bean是否实现了Aware相关的接口，如果实现了接口则调用这些接口中的方法。
          然后调用这些方法的目的是为了给你传递一些数据，让你更加方便使用。
    点位2：在""Bean后处理器""before方法之后
    点位3：使用Bean之后，或者说销毁Bean之前
    添加的这三个点位的特点：都是在检查你这个Bean是否实现了某些特定的接口，如果实现了这些接口，则Spring容器会调用这个接口中的方法。",2022-10-31 15:39:05,2,0
回复 @不用去猜-- :还得是老杜啊,2022-12-09 03:01:58,0,0
回复 @动力节点 :什么时候让老杜出一期讲juc的呀,2022-11-26 06:31:21,1,0
回复 @不要饿着肚子去上学 :在老杜的路上越走越远,2022-11-26 03:27:08,1,0
回复 @半糖森林5 :加油！,2022-11-22 03:21:50,0,0
回复 @杞都书画 :配车吗,2022-11-17 02:06:29,2,0
回复 @满满1227 :老杜yyds,2022-11-17 02:36:59,0,0
回复 @花卷sday :优秀啊,2022-11-08 01:59:43,0,0
回复 @Dreamt小豪 :几天了呀,2022-11-08 01:59:54,0,0
回复 @动力节点 :嗯嗯～,2022-11-08 04:41:41,0,0
回复 @辰星Rem0 :加油加油,2022-11-08 02:08:30,0,0
回复 @风风中的歌啊 :好的~~,2022-11-08 02:09:47,0,0
回复 @眰恦嗷呜 :加油加油,2022-11-08 02:12:14,1,0
回复 @ToubGe :优秀~,2022-11-07 02:24:15,0,0
回复 @WarmZzzz :加油加油,2022-11-07 02:37:25,0,0
回复 @小酷思密达 :ヾ(◍°∇°◍)ﾉﾞ,2022-11-04 02:11:18,0,0
回复 @打野从不开龙 :加油加油,2022-11-02 01:51:18,0,0
回复 @动力节点 :呜呜，现在才开始打卡，我是不是拿不到奖励了。,2022-11-02 04:04:59,0,0
回复 @大数_定律 :加油加油,2022-11-02 01:52:08,0,0
回复 @yc666666666666 :加油加油,2022-11-02 01:52:25,0,0
回复 @小酷思密达 :加油加油,2022-11-02 01:53:55,0,0
回复 @故离_ovo :加油加油,2022-11-02 01:54:27,0,0
回复 @小酷思密达 :滴~ 今日打卡成功,2022-11-01 02:37:07,1,0
